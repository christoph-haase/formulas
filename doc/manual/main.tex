\documentclass[10pt,english,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{babel}

\usepackage[svgnames]{xcolor}
\usepackage{a4wide}
\usepackage{graphicx}
\usepackage{url}
\usepackage{eurosym}
\usepackage{vmargin}
\usepackage{fancyhdr}
\usepackage{multicol}
\usepackage{lastpage}
\usepackage{eso-pic}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{longtable}
\usepackage{syntax}

\setlength{\grammarindent}{10em}

\synctex=1

\newcommand{\CC}{%
  C\nolinebreak\hspace{-.05em}\raisebox{.4ex}{\scriptsize\bf +}\nolinebreak\hspace{-.10em}\raisebox{.4ex}{\scriptsize\bf +}%
}

%\definecolor{listinggray}{gray}{0.92}
\lstdefinelanguage{rnc}
{ morekeywords={element, complexType, sequence, ID, IDREF, complexContent, extension, attribute}
, morekeywords=[2]{name, minOccurs, maxOccurs, ref, type, substitutionGroup, base, abstract}
, morekeywords=[3]{xs, mcc}
, basicstyle=\scriptsize\fontfamily{fvm}\selectfont
, keywordstyle=\scriptsize\fontfamily{fvm}\selectfont\color{Purple}
, keywordstyle=[2]\scriptsize\fontfamily{fvm}\selectfont\color{DarkBlue}
, keywordstyle=[3]\scriptsize\fontfamily{fvm}\selectfont\color{ForestGreen}
, stringstyle=\scriptsize\fontfamily{fvm}\selectfont\color{FireBrick}
, morestring=[b]"
, backgroundcolor=\color{blue!10}
}
\lstset{
  rulecolor=\color{black}
, breaklines=true
, tabsize=2
, flexiblecolumns=false
, keywordstyle=\bfseries
, basicstyle=\scriptsize\ttfamily
, xleftmargin=1cm
, xrightmargin=1cm
, language=rnc
}
\lstdefinelanguage{xsd}
{ morekeywords={element, complexType, sequence, ID, IDREF, complexContent, extension, attribute}
, morekeywords=[2]{name, minOccurs, maxOccurs, ref, type, substitutionGroup, base, abstract}
, morekeywords=[3]{xs, mcc}
, basicstyle=\scriptsize\fontfamily{fvm}\selectfont
, keywordstyle=\scriptsize\fontfamily{fvm}\selectfont\color{Purple}
, keywordstyle=[2]\scriptsize\fontfamily{fvm}\selectfont\color{DarkBlue}
, keywordstyle=[3]\scriptsize\fontfamily{fvm}\selectfont\color{ForestGreen}
, stringstyle=\scriptsize\fontfamily{fvm}\selectfont\color{FireBrick}
, morestring=[b]"
, backgroundcolor=\color{blue!10}
}
\lstdefinelanguage{mpl}
{ basicstyle=\scriptsize\fontfamily{fvm}\selectfont
, keywordstyle=\scriptsize\fontfamily{fvm}\selectfont\color{Purple}
, stringstyle=\scriptsize\fontfamily{fvm}\selectfont\color{FireBrick}
, morestring=[b]"
, backgroundcolor=\color{green!10}
}

\definecolor{rulercolor}{RGB}{255,255,255}
\definecolor{sectioncolor}{RGB}{50,50,50}
\definecolor{defaultcolor}{RGB}{100,37,16}

\oddsidemargin = 1cm
\evensidemargin = 1cm
\textwidth = 19cm
\topmargin = 1.2cm
\textheight = 24cm
\parskip = 0.1cm
\parindent = 0.0cm

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\lhead{\textcolor{rulercolor}{Model Checking Contest @ Petri Nets}\\\ \\}
\chead{\textcolor{rulercolor}{Page {\thepage}/\pageref{LastPage}}\\\ \\\color{rulercolor}\rule{19cm}{1.5pt}}
\rhead{\textcolor{rulercolor}{Property Language Manual}\\\ \\}

\lfoot{}
\cfoot{}
\rfoot{}

\renewcommand{\headrulewidth}{0pt}
\renewcommand{\footrulewidth}{0pt}
%%%%%%%%%%%%% pour un fond
\newcommand\BackgroundPic{
\put(0,0){
\parbox[b][\paperheight]{\paperwidth}{%
\vfill
\centering
\includegraphics[width=24cm,keepaspectratio]{background.jpg}%
\vfill
}}}
%%%%%%%%%%%%%%%%%%%%%%%%% fin fond

\renewcommand{\rmdefault}{phv}
\renewcommand{\sfdefault}{cmr}
%\renewcommand{\ttdefault}{pcr}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\fk}[1]{\color{blue}FK: #1\color{defaultcolor}\ }
\newcommand{\fp}[1]{\color{red}FK: #1\color{defaultcolor}\ }

\newcommand{\mcc}[0]{MCC}
\newcommand{\mccl}[0]{Model Checking Contest @ Petri Nets}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand\myparagraph[1]{\color{sectioncolor}\smallskip\textbf{#1. }\color{defaultcolor}}
\newcommand\mysection[1]{\color{sectioncolor}\section{#1}\color{defaultcolor}}
\newcommand\mysubsection[1]{\color{sectioncolor}\subsection{#1}\color{defaultcolor}}

\pagestyle{fancy}
\AddToShipoutPicture{\BackgroundPic}

\begin{document}
\color{defaultcolor}

\section*{Goals of the property language}
The property language for the \mcc{} @ Petri Nets is a language designed to allow
participation of many tools.
It allows to write structural, reachability, CTL, LTL formul{\ae}.
It is tightly related to Petri nets, that are the modeling formalism used during the contest.

This language is designed to evolve in the future editions of the contest.
It is also designed to integrate with Petri Net Markup Language in the future.
To do so, the language is provided as a RelaxNG grammar and an XML Schema generated from it.

\tableofcontents
%\clearpage

\section{Description of the langage}
The property language is designed as a RelaxNG grammar. Thus, properties are given in XML.
We generate a text equivalent from it, but it is not stable and only given for readability.

\begin{lstlisting}
  default namespace = "http://mcc.lip6.fr/"
  start = property-set
\end{lstlisting}
\subsection{Property sets}
The \lstinline[language=xsd]!property-set! element is the root of the XML representation.
It contains several properties.
\begin{lstlisting}
  default namespace = "http://mcc.lip6.fr/"
  start = property-set

  property-set = element property-set {
    property*
  }
\end{lstlisting}

\subsection{Properties}
A property is composed of three mandatory parts: a unique identifier, a textual description
of the property, and a formula.
%It has a set of tags to give a hint about the class of tools that can compute the formula
%(structural, reachability, CTL or LTL). These hints do \emph{not} say that the formula
%is expressed exactly in the language given by the hint, but tells that given minor changes,
%it could be.

%A property also contains an optional part for the expected result.
%It gives the expected value and a textual explanation.
%% \begin{lstlisting}
%%   property = element property {
%%     element id {
%%       xsd:ID
%%     } &
%%     element description {
%%       text
%%     } &
%%     element tags {
%%       element is-structural { xsd:boolean } &
%%       element is-reachability  { xsd:boolean } &
%%       element is-ctl { xsd:boolean } &
%%       element is-ltl { xsd:boolean }
%%     } &
%%     element expected-result {
%%       element value {
%%         xsd:integer | xsd:boolean
%%       } &
%%       element explanation {
%%         text
%%       }
%%     }? &
%%     element formula {
%%       formula
%%     }
%%   }
%% \end{lstlisting}

\begin{lstlisting}
  property = element property {
    element id {
      xsd:ID
    } &
    element description {
      text
    } &
    element formula {
      formula
    }
  }
\end{lstlisting}


\subsection{Formul{\ae}}
Formul{\ae} are the body of properties.
They define what is expected to hold on the model.
Formulas are currently of two main types: formul{\ae} that return integers, and formul{\ae}
that return Booleans.

In the following, for each rule of the grammar defining formulæ we give the RelaxNG representation (on the left) as well as another representation (on the right). This second representation will hopefully help the reader getting better intuition of the allowed formulæ. This representation will be used later to define the subclasses of formulæ considered in each category of the MCC. 

\begin{multicols}{2}
\begin{lstlisting}
  formula =
      boolean-formula
    | integer-formula
\end{lstlisting}
\columnbreak
\begin{grammar}
<formula> ::= <boolean-formula>
\alt <integer-formula>
\end{grammar}
\end{multicols}

%\clearpage
\subsection{Boolean formul{\ae}}

Boolean formul{\ae} are the majority of available formul{\ae}.
We define them in several parts.

\begin{lstlisting}
  boolean-formula = ...
\end{lstlisting}

%% \subsubsection{Reachability operators}

%% \begin{lstlisting}
%%   boolean-formula =
%%       ...
%%     | element invariant {
%%         boolean-formula
%%       }
%%     | element impossibility {
%%         boolean-formula
%%       }
%%     | element possibility {
%%         boolean-formula
%%       }
%%     | ...
%% \end{lstlisting}

%% \begin{itemize}
%%   \item \lstinline!invariant! evaluates to true if its subformula
%%     is verified for all states of the system;
%%   \item \lstinline!impossibility! evaluates to true if its subformula
%%     is never verified for all states of the system;
%%   \item \lstinline!possibility! evaluates to true if its subformula
%%     is verified for some states of the system (at least one).
%% \end{itemize}

\subsubsection{State operators}

These operators are the \lstinline!A! and \lstinline!E! operators of CTL.

\begin{multicols}{2}
\begin{lstlisting}
  boolean-formula =
      ...
    | element all-paths {
        boolean-formula
      }
    | element exists-path {
        boolean-formula
      }
    | ...
\end{lstlisting}
\columnbreak
\begin{grammar}
<boolean-formula> ::= A <boolean-formula>
\alt E <boolean-formula>
\end{grammar}
\end{multicols}

\subsubsection{Path operators}

These operators are the \lstinline!X!, \lstinline!G!, \lstinline!F! and \lstinline!U!
operators of CTL and LTL.

%% \begin{lstlisting}
%%   boolean-formula =
%%       ...
%%     | element globally {
%%         boolean-formula
%%       }
%%     | element finally {
%%         boolean-formula
%%       }
%%     | element next {
%%         boolean-formula &
%%         element if-no-successor { xsd:boolean } &
%%         element steps { xsd:positiveInteger }
%%       }
%%     | element until {
%%         element before {
%%           boolean-formula
%%         } &
%%         element reach {
%%           boolean-formula
%%         } &
%%         element strength {
%%           "weak" | "strong"
%%         }
%%       }
%%     | ...
%% \end{lstlisting}

\begin{multicols}{2}
\begin{lstlisting}
  boolean-formula =
      ...
    | element globally {
        boolean-formula
      }
    | element finally {
        boolean-formula
      }
    | element next {
        boolean-formula &
    | element until {
        element before {
          boolean-formula
        } &
        element reach {
          boolean-formula
        } &
      }
    | ...
\end{lstlisting}
\columnbreak
\begin{grammar}
<boolean-formula> ::= G <boolean-formula>
\alt F <boolean-formula>
\alt X <boolean-formula>
\alt <boolean-formula> U <boolean-formula>
\end{grammar}
\end{multicols}


\begin{itemize}
  \item \lstinline!next! should evaluate to false if no successor state exists;
  %\item \lstinline!until! has a \lstinline!strength! modifier, allowing the weak until.
\end{itemize}

\subsubsection{Petri net operators}

\begin{multicols}{2}
\begin{lstlisting}
  boolean-formula =
      ...
    | element deadlock { empty }
    | element is-fireable {
        transition+
      }
    | ...
\end{lstlisting}
\columnbreak
\begin{grammar}
<boolean-formula> ::= deadlock
\alt is-fireable($t_1$,\dots,$t_n$)
\end{grammar}
\end{multicols}


\begin{itemize}
  \item \lstinline!deadlock! evaluates to true if the current state is a dealock
    (has no successor);
  \item \lstinline!is-fireable! evaluates to true if one of the set of transitions given
    is fireable from the current state.
\end{itemize}

\subsubsection{Boolean operators}

These are usual Boolean operators.

%% \begin{lstlisting}
%%   boolean-formula =
%%       ...
%%     | element true  { empty }
%%     | element false { empty }
%%     | element negation {
%%         boolean-formula
%%       }
%%     | element conjunction {
%%         boolean-formula,
%%         boolean-formula+
%%       }
%%     | element disjunction {
%%         boolean-formula,
%%         boolean-formula+
%%       }
%%     | element exclusive-disjunction {
%%         boolean-formula,
%%         boolean-formula+
%%       }
%%     | element implication {
%%         boolean-formula,
%%         boolean-formula
%%       }
%%     | element equivalence {
%%         boolean-formula,
%%         boolean-formula+
%%       }
%%     | ...
%% \end{lstlisting}

\begin{multicols}{2}
\begin{lstlisting}
  boolean-formula =
      ...
    | element negation {
        boolean-formula
      }
    | element conjunction {
        boolean-formula,
        boolean-formula+
      }
    | element disjunction {
        boolean-formula,
        boolean-formula+
      }
    | ...
\end{lstlisting}
\columnbreak
\begin{grammar}
<boolean-formula> ::= $\lnot$ <boolean-formula>
\alt <boolean-formula> $\wedge$ <boolean-formula>
\alt <boolean-formula> $\vee$ <boolean-formula>
\end{grammar}
\end{multicols}


\subsubsection{Comparison operator}

This is the less or equal integer comparison operator.

%% \begin{lstlisting}
%%   boolean-formula =
%%       ...
%%     | element integer-eq {
%%         integer-expression,
%%         integer-expression
%%       }
%%     | element integer-ne {
%%         integer-expression,
%%         integer-expression
%%       }
%%     | element integer-lt {
%%         integer-expression,
%%         integer-expression
%%       }
%%     | element integer-le {
%%         integer-expression,
%%         integer-expression
%%       }
%%     | element integer-gt {
%%         integer-expression,
%%         integer-expression
%%       }
%%     | element integer-ge {
%%         integer-expression,
%%         integer-expression
%%       }
%%     | ...
%% \end{lstlisting}

\begin{multicols}{2}
\begin{lstlisting}
  boolean-formula =
      ...
    | element integer-le {
        integer-expression,
        integer-expression
      }
    | ...
\end{lstlisting}
\columnbreak
\begin{grammar}
<boolean-formula> ::= <integer-expression> $\leq$ <integer-expression>
\end{grammar}
\end{multicols}


\subsection{Integer formul{\ae}}

An integer formula is an integer expression.
The tool must return the integer, that is the result of the expression.

\begin{multicols}{2}
\begin{lstlisting}
  integer-formula =
      integer-expression

  integer-expression = ...
\end{lstlisting}
\columnbreak
\begin{grammar}
<integer-formula> ::= <integer-expression>
\end{grammar}
\end{multicols}

\subsubsection{Arithmetic operators}

These are usual arithmetic operators for integers.

%% \begin{lstlisting}
%%   integer-expression =
%%       ...
%%     element integer-constant {
%%       xsd:integer
%%     }
%%   | element integer-sum {
%%       integer-expression,
%%       integer-expression+
%%     }
%%   | element integer-product {
%%       integer-expression,
%%       integer-expression+
%%     }

%%   | element integer-difference {
%%       integer-expression,
%%       integer-expression
%%     }

%%   | element integer-division {
%%       integer-expression,
%%       integer-expression
%%     }
%%     | ...
%% \end{lstlisting}

\begin{multicols}{2}
\begin{lstlisting}
  integer-expression =
      ...
  | element integer-constant {
      xsd:integer
    }
  | element integer-sum {
      integer-expression,
      integer-expression+
    }
  | element integer-difference {
      integer-expression,
      integer-expression
    }
  | ...
\end{lstlisting}
\columnbreak
\begin{grammar}
<integer-expression> ::= integer-constant
\alt <integer-expression> + <integer-expression>
\alt <integer-expression> - <integer-expression>
\end{grammar}
\end{multicols}


\subsubsection{Petri net operators}

\begin{multicols}{2}
\begin{lstlisting}
  integer-expression =
      ...
  | element place-bound {
      place+
    }
  | element tokens-count {
      place+
    | ...
\end{lstlisting}
\columnbreak
\begin{grammar}
<integer-expression> ::= place-bound($p_1$,\dots,$p_n$)
\alt tokens-count($p_1$,\dots,$p_n$)
\end{grammar}
\end{multicols}

\begin{itemize}
  \item \lstinline!place-bound! returns the exact of estimated bound of a set of places;
    for several places, it means the maximum number of tèkens in all these places at the same
    time;
  \item \lstinline!tokens-count! returns the exact number of tokens in a set of places.
\end{itemize}

\subsection{Places and Transitions}

Places and transitions are uniquely identified. The identifiers are those of the PNML file.

\begin{lstlisting}
  place =
      element place {
        xsd:IDREF
      }

  transition =
      element transition {
        xsd:IDREF
      }
\end{lstlisting}


\section{Categories of properties}

For each category of properties used at MCC we give the restriction of the above grammar (for formulæ) that will be used.
Each category is designated by the name of the XML file providing the properties from this category.

\subsection{ReachabilityDeadlock.xml}

\begin{grammar}

<formula> ::= <boolean-formula>

<boolean-formula> ::= E F deadlock 
\alt A G $\lnot$ deadlock

\end{grammar}

\subsection{ReachabilityFireabilitySimple.xml}

\begin{grammar}

<formula> ::= <boolean-formula> 

<boolean-formula> ::= E F is-fireable($t_1$,\dots,$t_n$)

\end{grammar}

\subsection{ReachabilityFireability.xml}

\begin{grammar}

<formula> ::= <boolean-formula>

<boolean-formula> ::= E F is-fireable($t_1$,\dots,$t_n$)
\alt A G $\lnot$ is-fireable($t_1$,\dots,$t_n$)
\alt A G is-fireable($t_1$,\dots,$t_n$)

\end{grammar}


\clearpage
\section{Tools}
The RelaxNG grammar can be downloaded from~\url{http://mcc.lip6.fr/properties/mcc-properties.rnc} using:
\begin{lstlisting}[language=sh]
  wget http://mcc.lip6.fr/properties/mcc-properties.rnc
\end{lstlisting}

The XML schema file can be downloaded from~\url{http://mcc.lip6.fr/properties/mcc-properties.xsd} using:
\begin{lstlisting}[language=sh]
  wget http://mcc.lip6.fr/properties/mcc-properties.xsd
\end{lstlisting}

\subsection{How to generate the XML schema from the RelaxNG grammar?}
The Trang tool is able to transform the RelaxNG grammar into an XML Schema.
Visit \url{http://www.thaiopensource.com/relaxng/trang.html} to install this tool.

\begin{lstlisting}[language=sh]
  trang -I rnc -O xsd mcc-properties.rnc mcc-properties.xsd
\end{lstlisting}

\subsection{How to generate C++ classes from the XML Schema?}
Generation of {\CC} classes requires Code Synthesis' xsd tool
(\url{http://www.codesynthesis.com/products/xsd/}).
This tool converts the XML Schema of the property language to a set of \CC{} classes,
an XML validating parser, and an XML output.
This tool is free software, and is available for numerous platforms.
It is available at \url{http://www.codesynthesis.com/products/xsd/download.xhtml}.
Parsing and validating XML also requires to install Xerces-\CC{},
available at \url{http://xerces.apache.org/xerces-c/}.

After installing the \lstinline!xsd! tool,
you have to fix the file \lstinline!xsd/cxx/zc-istream.txx!:
\begin{lstlisting}[language=C++]
35c35
<       setg (b, b, e);
---
>       this->setg (b, b, e);
\end{lstlisting}

The conversion from the XML Schema to \CC{} classes is then performed using the following command:
\begin{lstlisting}[language=sh]
  mkdir -o src/cxx/
  xsd cxx-tree \
      --generate-serialization \
      --generate-doxygen \
      --generate-ostream \
      --generate-comparison \
      --generate-detach \
      --generate-default-ctor \
      --generate-polymorphic --polymorphic-type-all \
      --namespace-map http://mcc.lip6.fr=mcc \
      --output-dir src/cxx/ \
      --root-element property-set \
      mcc-properties.xsd
\end{lstlisting}

\subsection{How to generate Java classes from the XML Schema?}
Conversion from the XML Schema to Java classes requires the Java Architecture for XML Binding
(JAXB -- \url{http://jaxb.java.net/}).
It is included in recent Java distributions.

To generate the classes, use the following command:
\begin{lstlisting}[language=sh]
  mkdir -o src/java/
  xjc -d src/java/ -p mcc mcc-properties.xsd
\end{lstlisting}
It generates a set of Java files in the \lstinline!java! directory.

\subsection{How to generate Python classes from the XML Schema?}
The python script generateDS (\url{http://www.rexx.com/~dkuhlman/generateDS.html}) generates Python code from the XML Schema.

\begin{lstlisting}[language=sh]
  mkdir -p src/python/
  python generateDS.py -m -f --silence -o src/python/mcc-properties.py mcc-properties.xsd
\end{lstlisting}

\subsection{How to generate C\# classes from the XML Schema?}
There seems to be also tools for C\# developers: \\
\url{http://stackoverflow.com/questions/386155/comparison-of-xsd-codegenerators-c}.
We did not test them, but are interested by feedback if you use one.

\end{document}
